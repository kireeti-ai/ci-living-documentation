import argparse
import os
from epic4.config import config
from epic4.utils import logger
from epic4.summary import generate_summary
from epic4.storage_client import StorageClient

def main():
    parser = argparse.ArgumentParser(description="Epic-4 CI Automation")
    parser.add_argument("--impact", default=config.IMPACT_REPORT_PATH, help="Path to impact report")
    parser.add_argument("--drift", default=config.DRIFT_REPORT_PATH, help="Path to drift report")
    parser.add_argument("--docs", default=config.DOCS_DIR, help="Path to docs directory")
    parser.add_argument("--commit", default=config.COMMIT_SHA, help="Commit SHA")
    parser.add_argument("--mode", default="SUMMARY_ONLY_MODE", help="Execution mode: FULL_MODE or SUMMARY_ONLY_MODE")

    args = parser.parse_args()

    # 1. Validation & Input Loading
    # Temporarily force summary-only behavior.
    effective_mode = "SUMMARY_ONLY_MODE"

    # Load doc_snapshot.json to get dynamic bucket path and project_id
    docs_bucket_path = None
    project_id = None
    commit_hash = args.commit
    summary_local_dir = config.SUMMARIES_DIR  # Default fallback
    summary_bucket_path = None
    
    if os.path.exists(config.DOC_SNAPSHOT_PATH):
        try:
            import json
            with open(config.DOC_SNAPSHOT_PATH, 'r') as f:
                snapshot = json.load(f)
                # Extract project_id and commit
                project_id = snapshot.get("project_id")
                commit_from_snapshot = snapshot.get("commit")
                
                # Extract docs_bucket_path from snapshot (REQUIRED)
                # Format: "<project_id>/<commit_hash>/docs/"
                docs_bucket_path = snapshot.get("docs_bucket_path")
                
                if docs_bucket_path:
                    # Derive summary_bucket_path as: docs_bucket_path + "summary/"
                    # This gives us: "<project_id>/<commit_hash>/docs/summary/"
                    summary_path_relative = docs_bucket_path + "summary/"
                    
                    # Construct full R2 URI: r2://<bucket_name>/<path>
                    summary_bucket_path = f"r2://{config.R2_BUCKET_NAME}/{summary_path_relative}"
                    logger.info(f"Derived summary_bucket_path: {summary_bucket_path}")
                else:
                    logger.error("docs_bucket_path not found in doc_snapshot.json")
                    raise ValueError("docs_bucket_path is required in doc_snapshot.json")
                
                if project_id:
                    logger.info(f"Loaded project_id from snapshot: {project_id}")
                else:
                    logger.warning("project_id not found in doc_snapshot.json")
                
                # Use commit from snapshot if available
                if commit_from_snapshot:
                    commit_hash = commit_from_snapshot
                    logger.info(f"Using commit from snapshot: {commit_hash}")
                    
        except Exception as e:
            logger.error(f"Failed to load doc_snapshot.json: {e}")
            raise
    else:
        logger.error(f"doc_snapshot.json not found at {config.DOC_SNAPSHOT_PATH}")
        raise FileNotFoundError(f"doc_snapshot.json is required at {config.DOC_SNAPSHOT_PATH}")

    logger.info(f"Starting Epic-4 execution for commit {commit_hash} in mode {effective_mode}")

    storage_client = StorageClient()

    # 2. Generate Summary with fault tolerance
    summary_md_path = ""
    summary_json_path = ""
    
    try:
        summary_md_path, summary_json_path = generate_summary(args.impact, args.drift, commit_hash, summary_local_dir, snapshot)
        with open(summary_md_path, 'r') as f:
            summary_content = f.read()
        logger.info(f"Summary generated successfully at {summary_md_path}")
    except Exception as e:
        logger.error(f"Failed to generate summary: {e}")
        # Create error summary for partial artifact preservation
        summary_md_path = os.path.join(summary_local_dir, "summary.md")
        summary_json_path = os.path.join(summary_local_dir, "summary.json")
        os.makedirs(summary_local_dir, exist_ok=True)
        
        summary_content = f"""# Change Summary - Generation Failed

**Commit SHA:** `{commit_hash}`
**Status:** ERROR

## Error
Summary generation encountered an error:
```
{str(e)}
```

This is a degraded artifact. Please check the impact and drift reports manually.

---
*Generated by Epic-4 Automation*
"""
        with open(summary_md_path, 'w') as f:
            f.write(summary_content)
            
        with open(summary_json_path, 'w') as f:
            import json
            json.dump({"error": str(e), "status": "ERROR", "commit_sha": commit_hash}, f)
            
        logger.info(f"Created error summary at {summary_md_path}")

    # 3. Upload summary artifacts to cloud storage
    if summary_bucket_path:
        logger.info(f"Uploading summary artifacts to {summary_bucket_path}")
        upload_success_md = storage_client.upload_file(summary_md_path, summary_bucket_path)
        upload_success_json = storage_client.upload_file(summary_json_path, summary_bucket_path)
        
        if upload_success_md and upload_success_json:
            logger.info("Summary artifacts uploaded successfully")
        else:
            logger.error("Failed to upload one or more summary artifacts")
            raise RuntimeError("Summary upload failed")
    else:
        logger.error("No summary_bucket_path available for upload")
        raise ValueError("summary_bucket_path is required for upload")

    # 4. Emit response payload
    # Return the relative path (without scheme) as per specification
    summary_path_for_response = docs_bucket_path + "summary/" if docs_bucket_path else summary_bucket_path
    
    response = {
        "status": "success",
        "project_id": project_id,
        "commit": commit_hash,
        "summary_bucket_path": summary_path_for_response,
        "generated_files": [
            "summary.md",
            "summary.json"
        ]
    }

    try:
        import json
        print(json.dumps(response))
    except Exception:
        print(response)


if __name__ == "__main__":
    main()
