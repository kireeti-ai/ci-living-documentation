import axios from 'axios'

// Build the API URL from environment variables
// VITE_API_URL takes priority, otherwise construct from VITE_API_BASE + VITE_API_HOSTPORT
const getApiBaseUrl = () => {
  if (import.meta.env.VITE_API_URL) {
    return import.meta.env.VITE_API_URL
  }
  if (import.meta.env.VITE_API_HOSTPORT) {
    const base = import.meta.env.VITE_API_BASE || 'https://'
    return `${base}${import.meta.env.VITE_API_HOSTPORT}`
  }
  return 'https://ci-living-docs-backend.onrender.com'
}

const API_BASE_URL = getApiBaseUrl()

// Create axios instance
const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
})

// Request interceptor - attach access token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('access_token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// Response interceptor - handle 401 errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Clear token and redirect to login
      localStorage.removeItem('access_token')
      if (window.location.pathname !== '/login') {
        window.location.href = '/login'
      }
    }
    return Promise.reject(error)
  }
)

// Auth API
export const authApi = {
  signup: (data: { email: string; password: string; username: string }) =>
    api.post('/auth/signup', data),

  verifyOtp: (data: { email: string; otp: string }) =>
    api.post('/auth/signup/verify_otp', data),

  resendOtp: (email: string) =>
    api.post('/auth/resend_otp', { email }),

  login: (data: { email: string; password: string }) =>
    api.post('/auth/login', data),

  logout: () =>
    api.post('/auth/logout'),

  getMe: () =>
    api.get('/auth/me'),

  forgotPassword: (email: string) =>
    api.post('/auth/forgot-password', { email }),

  resetPassword: (data: { token: string; password: string; confirmPassword: string }) =>
    api.post('/auth/reset-password', data),
}

// Users API (Admin only)
export const usersApi = {
  getAll: () =>
    api.get('/users'),

  create: (data: { email: string; password: string; username: string; role: string }) =>
    api.post('/users', data),

  updateRole: (userId: string, role: string) =>
    api.patch(`/users/${userId}/role`, { role }),

  delete: (userId: string) =>
    api.delete(`/users/${userId}`),
}

// Projects API
export const projectsApi = {
  getAll: () =>
    api.get('/projects'),

  getById: (id: string) =>
    api.get(`/projects/${id}`),

  create: (data: { name: string; description?: string; githubUrl?: string }) =>
    api.post('/projects', data),

  update: (id: string, data: { name?: string; description?: string; githubUrl?: string }) =>
    api.put(`/projects/${id}`, data),

  delete: (id: string) =>
    api.delete(`/projects/${id}`),

  updateSettings: (id: string, data: { autoGenerateDocs?: boolean; githubAccessToken?: string | null }) =>
    api.put(`/projects/${id}/settings`, data),

  triggerDocGeneration: (id: string) =>
    api.post(`/projects/${id}/generate-docs`),

  inviteMember: (projectId: string, email: string) =>
    api.post(`/projects/${projectId}/invite`, { email }),

  cancelInvitation: (projectId: string, invitationId: string) =>
    api.delete(`/projects/${projectId}/invite/${invitationId}`),

  updateMemberRole: (projectId: string, memberId: string, role: string) =>
    api.patch(`/projects/${projectId}/members/${memberId}/role`, { role }),

  removeMember: (projectId: string, memberId: string) =>
    api.delete(`/projects/${projectId}/members/${memberId}`),
}

// Invitations API
export const invitationsApi = {
  getDetails: (token: string) =>
    api.get(`/invitations/${token}`),

  accept: (token: string) =>
    api.post(`/invitations/${token}/accept`),

  decline: (token: string) =>
    api.post(`/invitations/${token}/decline`),
}

// Document metadata type
export interface DocumentMetadata {
  version: string
  branch: string
  commit: string
  commitUrl: string
  branchUrl: string
  tags: string[]
  createdAt: string
  updatedAt: string
  title: string
  description?: string
}

// Document with metadata
export interface DocumentVersion {
  commit: string
  metadata: DocumentMetadata | null
}

// Documents list response
export interface DocumentsListResponse {
  projectId: string
  projectName: string
  documents: DocumentVersion[]
}

// Document detail response
export interface DocumentDetailResponse {
  projectId: string
  projectName: string
  commit: string
  content: string
  metadata: DocumentMetadata
}

export interface ArchitectureFile {
  name: string
  content: string
  lastModified: string | null
}

// Search result
export interface SearchResult {
  commit: string
  metadata: DocumentMetadata
  snippet: string
  matchCount: number
}

interface RawSearchResult {
  commit: string
  metadata: DocumentMetadata
  snippet?: string
  matchCount?: number
  matches?: string[]
}

// Filters response
export interface FiltersResponse {
  commits: string[]
  branches: string[]
  tags: string[]
}

// Search response
export interface SearchResponse {
  projectId: string
  projectName: string
  query: string
  results: RawSearchResult[]
}

// Documents API
export const documentsApi = {
  // List all documents for a project
  list: (projectId: string) =>
    api.get<DocumentsListResponse>(`/projects/${projectId}/documents`),

  // Get specific document commit with API content (from docs/api/api-description.json)
  get: (projectId: string, commit: string) =>
    api.get<DocumentDetailResponse>(`/projects/${projectId}/documents/${encodeURIComponent(commit)}`),

  // Get document summary (from docs/summary/summary.md)
  getSummary: (projectId: string, commit: string) =>
    api.get<{ content: string; projectName: string }>(`/projects/${projectId}/documents/${encodeURIComponent(commit)}/summary`),

  // Get document README (from docs/README.generated.md)
  getReadme: (projectId: string, commit: string) =>
    api.get<{ content: string; projectName: string }>(`/projects/${projectId}/documents/${encodeURIComponent(commit)}/readme`),

  // Get architecture files (from docs/architecture/*)
  getArchitecture: (projectId: string, commit: string) =>
    api.get<{ files: ArchitectureFile[]; projectName: string }>(
      `/projects/${projectId}/documents/${encodeURIComponent(commit)}/architecture`
    ),

  // Get only metadata for a commit
  getMetadata: (projectId: string, commit: string) =>
    api.get<DocumentMetadata>(`/projects/${projectId}/documents/${encodeURIComponent(commit)}/metadata`),

  // Search across all document commits
  search: async (projectId: string, query: string, filters?: { branch?: string; commit?: string; tags?: string[] }) => {
    const response = await api.post<SearchResponse>(`/projects/${projectId}/documents/search`, { query, ...filters })
    const normalizedResults: SearchResult[] = (response.data.results || []).map((result) => {
      const matches = Array.isArray(result.matches) ? result.matches : []
      const snippet = typeof result.snippet === 'string' && result.snippet.length > 0
        ? result.snippet
        : (matches[0] || '')
      const matchCount = typeof result.matchCount === 'number'
        ? result.matchCount
        : matches.length

      return {
        commit: result.commit,
        metadata: result.metadata,
        snippet,
        matchCount,
      }
    })

    return {
      ...response,
      data: {
        ...response.data,
        results: normalizedResults,
      },
    }
  },

  // Update document tags and version (owner/admin only)
  updateTags: (projectId: string, commit: string, tags: string[], version?: string) =>
    api.put(`/projects/${projectId}/documents/${encodeURIComponent(commit)}/tags`, { tags, version }),

  // Get available filter options
  getFilters: (projectId: string) =>
    api.get<FiltersResponse>(`/projects/${projectId}/documents/filters`),

  // Upload a test document (owner/admin only)
  testUpload: (projectId: string, data: {
    commitHash: string
    title: string
    summary?: string
    docs?: Array<{ filename: string; content: string }>
    branch?: string
    description?: string
    tags?: string[]
  }) => api.post(`/projects/${projectId}/documents/test-upload`, data),

  // Delete a document commit (owner/admin only)
  delete: (projectId: string, commit: string) =>
    api.delete(`/projects/${projectId}/documents/${encodeURIComponent(commit)}`),
}

export default api
