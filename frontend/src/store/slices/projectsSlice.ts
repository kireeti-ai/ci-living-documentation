import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'
import { projectsApi } from '../../services/api'

// Types
export interface ProjectMember {
  id: string
  userId: string
  role: 'owner' | 'admin' | 'member'
  joinedAt: string
  email: string
  username: string
}

export interface PendingInvitation {
  id: string
  email: string
  status: string
  createdAt: string
}

export interface ProjectSettings {
  autoGenerateDocs: boolean
  hasGithubToken: boolean
  hasWebhook?: boolean
}

export interface Project {
  id: string
  name: string
  description: string | null
  githubUrl: string | null
  ownerId: string
  createdAt: string
  updatedAt: string
  memberRole: 'owner' | 'admin' | 'member'
  members?: ProjectMember[]
  pendingInvitations?: PendingInvitation[]
  settings?: ProjectSettings
}

interface ProjectsState {
  projects: Project[]
  currentProject: Project | null
  isLoading: boolean
  error: string | null
}

const initialState: ProjectsState = {
  projects: [],
  currentProject: null,
  isLoading: false,
  error: null,
}

// Async Thunks
export const fetchProjects = createAsyncThunk(
  'projects/fetchAll',
  async (_, { rejectWithValue }) => {
    try {
      const response = await projectsApi.getAll()
      return response.data
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch projects')
    }
  }
)

export const fetchProjectById = createAsyncThunk(
  'projects/fetchById',
  async (id: string, { rejectWithValue }) => {
    try {
      const response = await projectsApi.getById(id)
      return response.data
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch project')
    }
  }
)

export const createProject = createAsyncThunk(
  'projects/create',
  async (data: { 
    name: string
    description?: string
    githubUrl: string
    autoGenerateDocs?: boolean
    githubAccessToken?: string 
  }, { rejectWithValue }) => {
    try {
      const response = await projectsApi.create(data)
      return response.data
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to create project')
    }
  }
)

export const updateProject = createAsyncThunk(
  'projects/update',
  async ({ id, data }: { id: string; data: { name?: string; description?: string } }, { rejectWithValue }) => {
    try {
      const response = await projectsApi.update(id, data)
      return response.data
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to update project')
    }
  }
)

export const deleteProject = createAsyncThunk(
  'projects/delete',
  async (id: string, { rejectWithValue }) => {
    try {
      await projectsApi.delete(id)
      return id
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to delete project')
    }
  }
)

export const updateProjectSettings = createAsyncThunk(
  'projects/updateSettings',
  async ({ id, data }: { id: string; data: { autoGenerateDocs?: boolean; githubAccessToken?: string | null } }, { rejectWithValue }) => {
    try {
      const response = await projectsApi.updateSettings(id, data)
      return { id, settings: response.data }
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to update settings')
    }
  }
)

export const inviteMember = createAsyncThunk(
  'projects/inviteMember',
  async ({ projectId, email }: { projectId: string; email: string }, { rejectWithValue }) => {
    try {
      const response = await projectsApi.inviteMember(projectId, email)
      return response.data
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to send invitation')
    }
  }
)

export const cancelInvitation = createAsyncThunk(
  'projects/cancelInvitation',
  async ({ projectId, invitationId }: { projectId: string; invitationId: string }, { rejectWithValue }) => {
    try {
      await projectsApi.cancelInvitation(projectId, invitationId)
      return invitationId
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to cancel invitation')
    }
  }
)

export const removeMember = createAsyncThunk(
  'projects/removeMember',
  async ({ projectId, memberId }: { projectId: string; memberId: string }, { rejectWithValue }) => {
    try {
      await projectsApi.removeMember(projectId, memberId)
      return memberId
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to remove member')
    }
  }
)

export const updateMemberRole = createAsyncThunk(
  'projects/updateMemberRole',
  async ({ projectId, memberId, role }: { projectId: string; memberId: string; role: string }, { rejectWithValue }) => {
    try {
      const response = await projectsApi.updateMemberRole(projectId, memberId, role)
      return response.data
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to update member role')
    }
  }
)

// Slice
const projectsSlice = createSlice({
  name: 'projects',
  initialState,
  reducers: {
    clearError: (state) => {
      state.error = null
    },
    clearCurrentProject: (state) => {
      state.currentProject = null
    },
  },
  extraReducers: (builder) => {
    // Fetch all projects
    builder
      .addCase(fetchProjects.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(fetchProjects.fulfilled, (state, action) => {
        state.isLoading = false
        state.projects = action.payload
      })
      .addCase(fetchProjects.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as string
      })

    // Fetch project by id
    builder
      .addCase(fetchProjectById.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(fetchProjectById.fulfilled, (state, action) => {
        state.isLoading = false
        state.currentProject = action.payload
      })
      .addCase(fetchProjectById.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as string
      })

    // Create project
    builder
      .addCase(createProject.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(createProject.fulfilled, (state, action) => {
        state.isLoading = false
        state.projects.push(action.payload)
      })
      .addCase(createProject.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as string
      })

    // Update project
    builder
      .addCase(updateProject.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(updateProject.fulfilled, (state, action) => {
        state.isLoading = false
        const index = state.projects.findIndex((p) => p.id === action.payload.id)
        if (index !== -1) {
          state.projects[index] = { ...state.projects[index], ...action.payload }
        }
        if (state.currentProject?.id === action.payload.id) {
          state.currentProject = { ...state.currentProject, ...action.payload }
        }
      })
      .addCase(updateProject.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as string
      })

    // Delete project
    builder
      .addCase(deleteProject.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(deleteProject.fulfilled, (state, action) => {
        state.isLoading = false
        state.projects = state.projects.filter((p) => p.id !== action.payload)
        if (state.currentProject?.id === action.payload) {
          state.currentProject = null
        }
      })
      .addCase(deleteProject.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as string
      })

    // Update project settings
    builder
      .addCase(updateProjectSettings.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(updateProjectSettings.fulfilled, (state, action) => {
        state.isLoading = false
        if (state.currentProject?.id === action.payload.id) {
          state.currentProject.settings = action.payload.settings
        }
      })
      .addCase(updateProjectSettings.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as string
      })

    // Invite member
    builder
      .addCase(inviteMember.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(inviteMember.fulfilled, (state, action) => {
        state.isLoading = false
        if (state.currentProject) {
          state.currentProject.pendingInvitations = [
            ...(state.currentProject.pendingInvitations || []),
            action.payload.invitation,
          ]
        }
      })
      .addCase(inviteMember.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as string
      })

    // Cancel invitation
    builder
      .addCase(cancelInvitation.fulfilled, (state, action) => {
        if (state.currentProject?.pendingInvitations) {
          state.currentProject.pendingInvitations = state.currentProject.pendingInvitations.filter(
            (inv) => inv.id !== action.payload
          )
        }
      })

    // Remove member
    builder
      .addCase(removeMember.fulfilled, (state, action) => {
        if (state.currentProject?.members) {
          state.currentProject.members = state.currentProject.members.filter(
            (m) => m.id !== action.payload
          )
        }
      })

    // Update member role
    builder
      .addCase(updateMemberRole.pending, (state) => {
        state.isLoading = true
        state.error = null
      })
      .addCase(updateMemberRole.fulfilled, (state, action) => {
        state.isLoading = false
        if (state.currentProject?.members) {
          const index = state.currentProject.members.findIndex(
            (m) => m.id === action.payload.id
          )
          if (index !== -1) {
            state.currentProject.members[index] = action.payload
          }
        }
      })
      .addCase(updateMemberRole.rejected, (state, action) => {
        state.isLoading = false
        state.error = action.payload as string
      })
  },
})

export const { clearError, clearCurrentProject } = projectsSlice.actions
export default projectsSlice.reducer
