import { Router, Request, Response } from 'express'
import { db } from '../db/index.js'
import { projects, projectSettings } from '../db/schema.js'
import { eq } from 'drizzle-orm'
import { verifyWebhookSignature, parseGitHubUrl } from '../utils/github.js'
import { uploadDocument, uploadDocumentMetadata, DocumentMetadata } from '../utils/r2.js'

const router = Router()

// GitHub Webhook handler - No authentication (uses signature verification)
router.post('/github', async (req: Request, res: Response) => {
  try {
    const signature = req.headers['x-hub-signature-256'] as string
    const event = req.headers['x-github-event'] as string
    const deliveryId = req.headers['x-github-delivery'] as string

    // Verify webhook signature
    const payload = JSON.stringify(req.body)
    if (!verifyWebhookSignature(payload, signature)) {
      console.warn(`Invalid webhook signature for delivery ${deliveryId}`)
      return res.status(401).json({ detail: 'Invalid signature' })
    }

    console.log(`Received GitHub webhook: ${event} (${deliveryId})`)

    // Handle different event types
    switch (event) {
      case 'push':
        await handlePushEvent(req.body)
        break
      case 'pull_request':
        await handlePullRequestEvent(req.body)
        break
      case 'release':
        await handleReleaseEvent(req.body)
        break
      case 'ping':
        // GitHub sends a ping event when webhook is created
        console.log('Webhook ping received:', req.body.zen)
        break
      default:
        console.log(`Unhandled event type: ${event}`)
    }

    return res.status(200).json({ received: true })
  } catch (error: any) {
    console.error('Webhook error:', error)
    return res.status(500).json({ detail: 'Webhook processing failed' })
  }
})

/**
 * Find project by GitHub repository URL
 */
const findProjectByRepo = async (repoUrl: string) => {
  // Try to find project with matching GitHub URL
  const [project] = await db
    .select()
    .from(projects)
    .where(eq(projects.githubUrl, repoUrl))
    .limit(1)

  if (project) {
    return project
  }

  // Also try with/without .git suffix
  const alternateUrl = repoUrl.endsWith('.git') 
    ? repoUrl.slice(0, -4) 
    : repoUrl + '.git'
  
  const [altProject] = await db
    .select()
    .from(projects)
    .where(eq(projects.githubUrl, alternateUrl))
    .limit(1)

  return altProject || null
}

/**
 * Handle push events - could trigger doc generation
 */
const handlePushEvent = async (payload: any) => {
  const repoUrl = payload.repository?.html_url
  const branch = payload.ref?.replace('refs/heads/', '')
  const commits = payload.commits || []
  const headCommit = payload.head_commit

  console.log(`Push to ${repoUrl} on branch ${branch}`)
  console.log(`${commits.length} commits, head: ${headCommit?.id?.substring(0, 7)}`)

  if (!repoUrl) return

  // Find the project
  const project = await findProjectByRepo(repoUrl)
  if (!project) {
    console.log(`No project found for repo: ${repoUrl}`)
    return
  }

  // Get project settings
  const [settings] = await db
    .select()
    .from(projectSettings)
    .where(eq(projectSettings.projectId, project.id))
    .limit(1)

  if (!settings?.autoGenerateDocs) {
    console.log(`Auto-generate docs is disabled for project: ${project.name}`)
    return
  }

  // TODO: Trigger documentation generation
  // For now, just log the event
  console.log(`Would trigger doc generation for ${project.name} on push`)
  
  // Create a placeholder document to show the webhook is working
  // Call code-detect API to analyze the repository
  try {
    const response = await fetch('https://code-detect.onrender.com/analyze', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        repo_url: repoUrl.endsWith('.git') ? repoUrl : `${repoUrl}.git`,
        branch,
        github_token: settings.githubAccessToken || undefined,
        project_id: project.id,
        new_user: true,
      }),
    })

    if (!response.ok) {
      console.error(`Code-detect API error: ${response.status} ${await response.text()}`)
    } else {
      const result = await response.json()
      console.log(`Code-detect analysis triggered for ${project.name}:`, result)

      // Pass the analysis result to generate-docs endpoint
      const generateDocsResponse = await fetch('https://ci-docs-gen.onrender.com/generate-docs', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          branch,
          commit_hash: headCommit?.id || 'unknown',
          impact_report: result,
          project_id: project.id,
          repo_url: repoUrl,
        }),
      })

      if (!generateDocsResponse.ok) {
        console.error(`Generate-docs API error: ${generateDocsResponse.status} ${await generateDocsResponse.text()}`)
      } else {
        const docsResult = await generateDocsResponse.json()
        console.log(`Documentation generated for ${project.name}:`)

        // Call generate-summary endpoint to create summary in the bucket
        const generateSummaryResponse = await fetch('https://ci-living-documentation.onrender.com/generate-summary', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            impact_report: result,
            drift_report: {},
            commit_sha: headCommit?.id || 'unknown',
            project_id: project.id,
          }),
        })

        if (!generateSummaryResponse.ok) {
          console.error(`Generate-summary API error: ${generateSummaryResponse.status} ${await generateSummaryResponse.text()}`)
        } else {
          const summaryResult = await generateSummaryResponse.json()
          console.log(`Summary generated for ${project.name}:`, summaryResult)
        }
      }
    }
  } catch (error) {
    console.error('Failed to call code-detect API:', error)
  }
}

/**
 * Handle pull request events
 */
const handlePullRequestEvent = async (payload: any) => {
  const action = payload.action // opened, closed, merged, etc.
  const pr = payload.pull_request
  const repoUrl = payload.repository?.html_url

  console.log(`PR ${action}: #${pr?.number} - ${pr?.title}`)

  if (!repoUrl) return

  // Find the project
  const project = await findProjectByRepo(repoUrl)
  if (!project) {
    console.log(`No project found for repo: ${repoUrl}`)
    return
  }

  // Only process merged PRs for now
  if (action !== 'closed' || !pr?.merged) {
    return
  }

  console.log(`PR #${pr.number} was merged in ${project.name}`)
  // TODO: Could trigger doc regeneration on merged PRs
}

/**
 * Handle release events
 */
const handleReleaseEvent = async (payload: any) => {
  const action = payload.action // published, created, etc.
  const release = payload.release
  const repoUrl = payload.repository?.html_url

  console.log(`Release ${action}: ${release?.tag_name} - ${release?.name}`)

  if (!repoUrl || action !== 'published') return

  // Find the project
  const project = await findProjectByRepo(repoUrl)
  if (!project) {
    console.log(`No project found for repo: ${repoUrl}`)
    return
  }

  console.log(`Release ${release.tag_name} published for ${project.name}`)
  
  // Create a release document
  const commitHash = release.target_commitish || `release-${release.tag_name}`
  const metadata: DocumentMetadata = {
    version: release.tag_name,
    branch: release.target_commitish || 'main',
    commit: release.target_commitish || '',
    commitUrl: '',
    branchUrl: `${repoUrl}/tree/${release.target_commitish || 'main'}`,
    tags: ['release', release.tag_name, release.prerelease ? 'prerelease' : 'stable'],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    title: release.name || release.tag_name,
    description: release.body || 'New release',
  }

  try {
    const summary = `# Release ${release.tag_name}

**Name:** ${release.name || release.tag_name}  
**Published:** ${release.published_at}  
**Author:** ${release.author?.login || 'unknown'}  
${release.prerelease ? '**Pre-release**' : '**Stable Release**'}

## Release Notes

${release.body || 'No release notes provided.'}

---

[View Release on GitHub](${release.html_url})

*This document was auto-generated by a release event.*
`
    await uploadDocument(project.id, commitHash, 'summaries', 'summary.md', summary)
    await uploadDocumentMetadata(project.id, commitHash, metadata)
    console.log(`Created release document for ${project.name}: ${commitHash}`)
  } catch (error) {
    console.error('Failed to create release document:', error)
  }
}

export default router
